/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/

#include "config.h"
#include "V8WorkerContext.h"

#if ENABLE(WORKERS)

#include "EventListener.h"
#include "ExceptionCode.h"
#include "RuntimeEnabledFeatures.h"
#include "V8AbstractEventListener.h"
#include "V8Binding.h"
#include "V8BindingMacros.h"
#include "V8BindingState.h"
#include "V8DOMWrapper.h"
#include "V8Database.h"
#include "V8DatabaseCallback.h"
#include "V8DatabaseSync.h"
#include "V8Event.h"
#include "V8EventListenerList.h"
#include "V8EventSource.h"
#include "V8IsolatedContext.h"
#include "V8MessageChannel.h"
#include "V8MessageEvent.h"
#include "V8NotificationCenter.h"
#include "V8Proxy.h"
#include "V8WebSocket.h"
#include "V8WorkerContextErrorHandler.h"
#include "V8WorkerLocation.h"
#include "V8WorkerNavigator.h"
#include "V8XMLHttpRequest.h"
#include <wtf/GetPtr.h>
#include <wtf/RefCounted.h>
#include <wtf/RefPtr.h>

namespace WebCore {

WrapperTypeInfo V8WorkerContext::info = { V8WorkerContext::GetTemplate, V8WorkerContext::derefObject, 0 };

namespace WorkerContextInternal {

template <typename T> void V8_USE(T) { }

static v8::Handle<v8::Value> selfAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.self._get");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    return toV8(imp->self());
}

static v8::Handle<v8::Value> locationAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.location._get");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    RefPtr<WorkerLocation> result = imp->location();
    v8::Handle<v8::Value> wrapper = result.get() ? getDOMObjectMap().get(result.get()) : v8::Handle<v8::Value>();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setHiddenReference(info.Holder(), wrapper);
    }
    return wrapper;
}

static v8::Handle<v8::Value> onerrorAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.onerror._get");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    return imp->onerror() ? v8::Handle<v8::Value>(static_cast<V8AbstractEventListener*>(imp->onerror())->getListenerObject(imp->scriptExecutionContext())) : v8::Handle<v8::Value>(v8::Null());
}

static void onerrorAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.onerror._set");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    transferHiddenDependency(info.Holder(), imp->onerror(), value, V8WorkerContext::eventListenerCacheIndex);
    imp->setOnerror(V8EventListenerList::findOrCreateWrapper<V8WorkerContextErrorHandler>(value, true));
    return;
}

static v8::Handle<v8::Value> navigatorAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.navigator._get");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    RefPtr<WorkerNavigator> result = imp->navigator();
    v8::Handle<v8::Value> wrapper = result.get() ? getDOMObjectMap().get(result.get()) : v8::Handle<v8::Value>();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setHiddenReference(info.Holder(), wrapper);
    }
    return wrapper;
}

static v8::Handle<v8::Value> webkitNotificationsAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.webkitNotifications._get");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    RefPtr<NotificationCenter> result = imp->webkitNotifications();
    v8::Handle<v8::Value> wrapper = result.get() ? getDOMObjectMap().get(result.get()) : v8::Handle<v8::Value>();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setHiddenReference(info.Holder(), wrapper);
    }
    return wrapper;
}

static v8::Handle<v8::Value> WorkerContextConstructorGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.constructors._get");
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal() || data->IsNumber());
    WrapperTypeInfo* type = WrapperTypeInfo::unwrap(data);
    return V8DOMWrapper::getConstructor(type, V8WorkerContext::toNative(info.Holder()));
}

static v8::Handle<v8::Value> closeCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.close");
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    imp->close();
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> openDatabaseCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.openDatabase");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::SyntaxError);
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, name, args[0]);
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, version, args[1]);
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, displayName, args[2]);
    EXCEPTION_BLOCK(unsigned, estimatedSize, toUInt32(args[3]));
    RefPtr<DatabaseCallback> creationCallback;
    if (args.Length() > 4 && !args[4]->IsNull() && !args[4]->IsUndefined()) {
        if (!args[4]->IsObject())
            return throwError(TYPE_MISMATCH_ERR);
        creationCallback = V8DatabaseCallback::create(args[4], getScriptExecutionContext());
    }
    RefPtr<Database> result = imp->openDatabase(name, version, displayName, estimatedSize, creationCallback, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release());
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> openDatabaseSyncCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.openDatabaseSync");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::SyntaxError);
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, name, args[0]);
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, version, args[1]);
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, displayName, args[2]);
    EXCEPTION_BLOCK(unsigned, estimatedSize, toUInt32(args[3]));
    RefPtr<DatabaseCallback> creationCallback;
    if (args.Length() > 4 && !args[4]->IsNull() && !args[4]->IsUndefined()) {
        if (!args[4]->IsObject())
            return throwError(TYPE_MISMATCH_ERR);
        creationCallback = V8DatabaseCallback::create(args[4], getScriptExecutionContext());
    }
    RefPtr<DatabaseSync> result = imp->openDatabaseSync(name, version, displayName, estimatedSize, creationCallback, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release());
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> clearTimeoutCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.clearTimeout");
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    EXCEPTION_BLOCK(int, handle, toInt32(args[0]));
    imp->clearTimeout(handle);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> clearIntervalCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.clearInterval");
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    EXCEPTION_BLOCK(int, handle, toInt32(args[0]));
    imp->clearInterval(handle);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> addEventListenerCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.addEventListener()");
    RefPtr<EventListener> listener = V8DOMWrapper::getEventListener(args[1], false, ListenerFindOrCreate);
    if (listener) {
        V8WorkerContext::toNative(args.Holder())->addEventListener(v8ValueToAtomicWebCoreString(args[0]), listener, args[2]->BooleanValue());
        createHiddenDependency(args.Holder(), args[1], V8WorkerContext::eventListenerCacheIndex);
    }
    return v8::Undefined();
}

static v8::Handle<v8::Value> removeEventListenerCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.removeEventListener()");
    RefPtr<EventListener> listener = V8DOMWrapper::getEventListener(args[1], false, ListenerFindOnly);
    if (listener) {
        V8WorkerContext::toNative(args.Holder())->removeEventListener(v8ValueToAtomicWebCoreString(args[0]), listener.get(), args[2]->BooleanValue());
        removeHiddenDependency(args.Holder(), args[1], V8WorkerContext::eventListenerCacheIndex);
    }
    return v8::Undefined();
}

static v8::Handle<v8::Value> dispatchEventCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.dispatchEvent");
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(Event*, evt, V8Event::HasInstance(args[0]) ? V8Event::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0);
    bool result = imp->dispatchEvent(evt, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result);
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

} // namespace WorkerContextInternal

static const BatchedAttribute WorkerContextAttrs[] = {
    // Attribute 'self' (Type: 'attribute' ExtAttr: 'Replaceable')
    {"self", WorkerContextInternal::selfAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None | v8::ReadOnly), 0 /* on instance */},
    // Attribute 'location' (Type: 'attribute' ExtAttr: 'Replaceable')
    {"location", WorkerContextInternal::locationAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None | v8::ReadOnly), 0 /* on instance */},
    // Attribute 'onerror' (Type: 'attribute' ExtAttr: '')
    {"onerror", WorkerContextInternal::onerrorAttrGetter, WorkerContextInternal::onerrorAttrSetter, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    // Attribute 'navigator' (Type: 'attribute' ExtAttr: 'Replaceable')
    {"navigator", WorkerContextInternal::navigatorAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None | v8::ReadOnly), 0 /* on instance */},
    // Attribute 'MessageEvent' (Type: 'attribute' ExtAttr: '')
    {"MessageEvent", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8MessageEvent::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'WorkerLocation' (Type: 'attribute' ExtAttr: '')
    {"WorkerLocation", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8WorkerLocation::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'MessageChannel' (Type: 'attribute' ExtAttr: 'JSCCustomGetter')
    {"MessageChannel", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8MessageChannel::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'EventSource' (Type: 'attribute' ExtAttr: 'JSCCustomGetter')
    {"EventSource", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8EventSource::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'XMLHttpRequest' (Type: 'attribute' ExtAttr: 'JSCCustomGetter')
    {"XMLHttpRequest", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8XMLHttpRequest::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
};
static const BatchedCallback WorkerContextCallbacks[] = {
    {"close", WorkerContextInternal::closeCallback},
    {"importScripts", V8WorkerContext::importScriptsCallback},
    {"setTimeout", V8WorkerContext::setTimeoutCallback},
    {"clearTimeout", WorkerContextInternal::clearTimeoutCallback},
    {"setInterval", V8WorkerContext::setIntervalCallback},
    {"clearInterval", WorkerContextInternal::clearIntervalCallback},
    {"addEventListener", WorkerContextInternal::addEventListenerCallback},
    {"removeEventListener", WorkerContextInternal::removeEventListenerCallback},
};
static v8::Persistent<v8::FunctionTemplate> ConfigureV8WorkerContextTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    v8::Local<v8::Signature> defaultSignature = configureTemplate(desc, "WorkerContext", v8::Persistent<v8::FunctionTemplate>(), V8WorkerContext::internalFieldCount,
        WorkerContextAttrs, sizeof(WorkerContextAttrs) / sizeof(*WorkerContextAttrs),
        WorkerContextCallbacks, sizeof(WorkerContextCallbacks) / sizeof(*WorkerContextCallbacks));
    v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
    
    if (RuntimeEnabledFeatures::webkitNotificationsEnabled()) {
        static const BatchedAttribute attrData =\
        // Attribute 'webkitNotifications' (Type: 'readonly attribute' ExtAttr: 'EnabledAtRuntime')
        {"webkitNotifications", WorkerContextInternal::webkitNotificationsAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */};
        configureAttribute(instance, proto, attrData);
    }
    if (RuntimeEnabledFeatures::webSocketEnabled()) {
        static const BatchedAttribute attrData =\
        // Attribute 'WebSocket' (Type: 'attribute' ExtAttr: 'JSCCustomGetter EnabledAtRuntime')
        {"WebSocket", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8WebSocket::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */};
        configureAttribute(instance, proto, attrData);
    }
    if (RuntimeEnabledFeatures::openDatabaseEnabled())
        proto->Set(v8::String::New("openDatabase"), v8::FunctionTemplate::New(WorkerContextInternal::openDatabaseCallback, v8::Handle<v8::Value>(), defaultSignature));
    if (RuntimeEnabledFeatures::openDatabaseSyncEnabled())
        proto->Set(v8::String::New("openDatabaseSync"), v8::FunctionTemplate::New(WorkerContextInternal::openDatabaseSyncCallback, v8::Handle<v8::Value>(), defaultSignature));

    // Custom Signature 'dispatchEvent'
    const int dispatchEventArgc = 1;
    v8::Handle<v8::FunctionTemplate> dispatchEventArgv[dispatchEventArgc] = { V8Event::GetRawTemplate() };
    v8::Handle<v8::Signature> dispatchEventSignature = v8::Signature::New(desc, dispatchEventArgc, dispatchEventArgv);
    proto->Set(v8::String::New("dispatchEvent"), v8::FunctionTemplate::New(WorkerContextInternal::dispatchEventCallback, v8::Handle<v8::Value>(), dispatchEventSignature));

    // Custom toString template
    desc->Set(getToStringName(), getToStringTemplate());
    return desc;
}

v8::Persistent<v8::FunctionTemplate> V8WorkerContext::GetRawTemplate()
{
    static v8::Persistent<v8::FunctionTemplate> V8WorkerContextRawCache = createRawTemplate();
    return V8WorkerContextRawCache;
}

v8::Persistent<v8::FunctionTemplate> V8WorkerContext::GetTemplate()
{
    static v8::Persistent<v8::FunctionTemplate> V8WorkerContextCache = ConfigureV8WorkerContextTemplate(GetRawTemplate());
    return V8WorkerContextCache;
}

WorkerContext* V8WorkerContext::toNative(v8::Handle<v8::Object> object)
{
    return reinterpret_cast<WorkerContext*>(object->GetPointerFromInternalField(v8DOMWrapperObjectIndex));
}

bool V8WorkerContext::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}


v8::Handle<v8::Object> V8WorkerContext::wrap(WorkerContext* impl)
{
    v8::Handle<v8::Object> wrapper;
    V8Proxy* proxy = 0;
        wrapper = getDOMObjectMap().get(impl);
        if (!wrapper.IsEmpty())
            return wrapper;
    wrapper = V8DOMWrapper::instantiateV8Object(proxy, &info, impl);
    if (wrapper.IsEmpty())
        return wrapper;

    impl->ref();
    getDOMObjectMap().set(impl, v8::Persistent<v8::Object>::New(wrapper));
    return wrapper;
}

v8::Handle<v8::Value> toV8(PassRefPtr<WorkerContext > impl)
{
    return toV8(impl.get());
}

void V8WorkerContext::derefObject(void* object)
{
    static_cast<WorkerContext*>(object)->deref();
}

} // namespace WebCore

#endif // ENABLE(WORKERS)
